L'objectif de ce projet est d'utiliser les notifications pouvant être générées par les différents serveurs de base de données pour détecter la désynchronisation entre des objets instanciées via Hibernate et leur version dans la base de données le plus tôt possible.

Utilisation typique d'Hibernate :
1 Ouverture d'une session (depuis une SessionFactory)
2 Ouverture d'une transaction
3 Chargement d'un objet (Load)
4 Modification de l'objet (Set)
5 Passage de l'objet modifié a la session (Persist)
6 Détection de la présence ou non de données modifiées dans l'objet (DirtyCheck)
7 Préparation par la session des requêtes SQL de modification si besoin (Update)
8 Exécution des requêtes (Flush) 
9 Commit
10 Fermeture de la session

Dans le cas d'un objet non versionné, Hibernate ne détecte pas si l'objet est désynchronisé. L'objet de la base de données sera écrasé systématiquement. Dans le cas des objets versionnés, ou si on l'a demandé explicitement pour les objets non versionnés (option optimistic-lock = all), Hibernate prépare les requêtes SQL en intégrant une clause WHERE qui va rendre l'update inopérant si l'objet n'est pas à jour. Lors de l'exécution des requêtes, Hibernate regarde le nombre de lignes affectées et en déduit l'état de synchronisation. Si on est désynchronisé, une StaleObjectStateException est lancée.

Actuellement, la désynchronisation est donc détectée au moment du flush. L'objectif de notre projet est d'éviter les requêtes inutiles à la base de données, voire même certains traitements mêtier inutiles car sur la base d'objets périmés.



Le répertoire src contient un début d'implémentation d'un système répondant a ce besoin. Il s'agit d'un EventListener Hibernate. En attachant cet EventListener aux évènements Hibernate qui nous intéressent, une instance de notre Listener sera crée avec la sessionFactory, et on pourra suivre les objets des différentes sessions et en fonction des notifications reçues depuis la base de données, lancer une StaleObjectStateException à une étape précédant le Flush.

Les bases de données considérées pour l'instant sont Oracle et PostgreSQL. Oracle semble avoir toutes les fonctionnalités nécessaires (voir le répertoire doc), tandis que le NOTIFY de PostgreSQL ne permet pas de passer ce qu'on veut comme information, et se limiterait donc a une notification par table, ce qui ne nous convient pas. Il pourrait éventuellement être intéressant de patcher PostgreSQL dans le cadre du projet (voir notes).

Le fichier notes contient les notes prises au fur et à mesure des réflexions, des problèmes rencontrés et des discussions avec Cyrille Chepelov.


Reste a faire :

=== listen/notify ===
CREATE RULE "listen_update" AS
	ON UPDATE TO objetpersistent
	DO ALSO NOTIFY 'UPDATE#'||objetpersistent||'#'||OLD.id; 

pas possible : syntaxe = notify <id_postgre>

si on peut convertir une string en identifiant, on pourrait utiliser un sha1 des infos interessantes. SHA1 en pgsql : 
encode(digest('ma chaine', 'sha1'), 'hex')

autres options : une rule par  en cache ou une rule pour tous les objets en cache updatee au fur et a mesure.
sauf que pas de ALTER RULE, donc DROP + CREATE a chaque fois

Mais un patch a ete propose qui permet de passer un parametre dans un NOTIFY : https://commitfest.postgresql.org/action/patch_view?id=210 on va donc pouvoir passer la table et l'id de l'objet qui a ete victime d'un update avec la prochaine version de postgresql !

Le patch semble ne supporter qu'un payload constant pour notify, ce qui n'apporte rien dans notre cas. En regardant la grammaire, il semblerait que le payload devrait etre un ctext_expr et pas un iconst, ce qui permettrait de mettre tout type de valeur comme payload, y compris un (select ...). Ca veut dire qu'il faudrait probablement transformer notify en preparable statement pour que le sql soit pris en compte.

Mail a Joachim Wieland (joe@mcknight.de), auteur du patch, 2 dec 2009

Concernant la possibilité d'utiliser une table mémoire contenant les pks des lignes updatées a la place du listen/notify : PostgreSQL peut stocker une table en RAM si on donne une LOCATION sur un ramdisk lors du CREATE... pas genial.

Il faudra penser a integrer les mappings restrictifs (WHERE ... ) pour ne pas tenir compte des objets non concernés dans les notifs ?

Avec Oracle, ca a l'air faisable : http://download.oracle.com/docs/cd/B28359_01/java.111/b31224/dbmgmnt.htm#CHDEJECF par contre il semble qu'il faille un thread dedié au listener. Par ailleurs Oracle ne retourne que des RowIDs... il va falloir trouver un moyen d'avoir une notif avec pk / version.
Pour oracle, c'est bon, on peut mettre ce qu'on veut dans les messages de notif : http://www.oracle.com/technology/products/ias/toplink/technical/tips/DbChangeNotification/index.htm

on a pas moyen de savoir si au moment du load, un objet n'est pas deja stale
Pas grave si on pert des notifs : on essaye juste de prevenir le plus tot possible. Dans tous les cas, le stalestate ariverra au commit au pire.

Avantages du systeme :
	- stale avant load
		- evition dirigee L2 par opposition au LRU
		- Eviter traitements metier inutiles
	- stale avant persist
		- L2
		- Eviter flush de tous les objets dirty de la transaction
	- stale avant dirtyCheck
		- L2
		- Eviter la verification de dirtyness, partant du principe qu'elle est plus couteuse que notre verification de version (?)
	- stale avant flush
		- L2
		- Eviter update voue a l'echec
	- stale avant commit
		- Evition L2 de version 
		- Si on a pas recu la notif, tant pis, l'update se fait et on revient au fonctionnement hibernate normal

Comment gere t'on la notification d'un delete ? En versionné, a t'on un soft-delete ?

Comment distingue t'on un objet versionné ? comment recuperer sa version ? comment la comparer a une autre ? toujours incrementé ? utiliser timestamp ?  Est-ce l'un ou l'autre ?
