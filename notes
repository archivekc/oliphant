select-before-update : seulement pour les objets transient ajoutes a la session via update.

Il semble qu'on puisse ajouter un where puisque check() verifie le number of rows affected et retourne une stale state exception
mais pas dans la logique d'hibernate : apparement si on est pas en mode versionne, pas de notion de stale

Cyrille : on va ajouter la notion de stale avec un update where toutes les colonnes pour les objets non versionnes, interet : bases qui ne peuvent pas etre passees en mode versions

=== listen/notify ===
CREATE RULE "listen_update" AS
	ON UPDATE TO objetpersistent
	DO ALSO NOTIFY 'UPDATE#'||objetpersistent||'#'||OLD.id; 

pas possible : syntaxe = notify <id_postgre>

si on peut convertir une string en identifiant, on pourrait utiliser un sha1 des infos interessantes. SHA1 en pgsql : 
encode(digest('ma chaine', 'sha1'), 'hex')

autres options : une rule par  en cache ou une rule pour tous les objets en cache updatee au fur et a mesure.
sauf que pas de ALTER RULE, donc DROP + CREATE a chaque fois

Mais un patch a ete propose qui permet de passer un parametre dans un NOTIFY : https://commitfest.postgresql.org/action/patch_view?id=210 on va donc pouvoir passer la table et l'id de l'objet qui a ete victime d'un update avec la prochaine version de postgresql !

On va faire une methode (voir ou la mettre) qui verifie une liste d'objets, et les passe a stale si necessaire. L'utilisateur pourra l'utiliser a la demande, et on l'utilisera aussi au debut du flush.

Dans un premier temps, on va faire un test en mettant tout le code dans flush

Apply du patch notify sur le dernier snapshot (2 decembre) : le patch passe, mais ca ne marche pas (syntax error quand on ajoute un payload dans un NOTIFY). Clonage du git (miroir du cvs) de postgresql, et recuperation de la version sur laquelle le patch semble s'appliquer : acfff4ac821da0f8088550fed65c4 (16 Nov). Make se plaint qu'il manque le parseur Bison, ce qui confirme qu'il devait y avoir un probleme de grammaire avec le snapshot (apparement bison sert a generer les .c a partir des .y pour la compilation, ce qui fait que le parseur que j'utilisais sur le snapshot etait celui du .c qui n'etait pas a jour)

Le patch semble ne supporter qu'un payload constant pour notify, ce qui n'apporte rien dans notre cas. En regardant la grammaire, il semblerait que le payload devrait etre un ctext_expr et pas un iconst, ce qui permettrait de mettre tout type de valeur comme payload, y compris un (select ...). Ca veut dire qu'il faudrait probablement transformer notify en preparable statement pour que le sql soit pris en compte.

Mail a Joachim Wieland (joe@mcknight.de), auteur du patch, 2 dec 2009
---------------------------------------------------

Sujet : your patch to PostgreSQL listen/notify

Hi,

I had a look at your patch, and played with it a bit. If I understand your code well, the payload for the notify has to be constant.
This bothers me since I was hoping the patch would allow me to pass a dynamic payload. My use case would be setting a notify rule on update on a table, and having the updated row pk, or some hashed form of it, as the notify payload, so listening applications could know which row was updated. The rule I had in mind would look like this in the simplest case:

CREATE RULE "listen_update" AS
	ON UPDATE TO my_table
	DO ALSO NOTIFY update_my_table OLD.id;

I'm not sure if there is any other way to do this apart from having a small table for storing updated ids, which would need to be queried regularly, which entails unnecessary database operations compared to a listen/notify implementation.
To allow for my use case, I was thinking about adding to your patch by changing the payload definition in the grammar to a ctext_expr or aexpr, so as to allow as a payload anything that coalesces to a suitable string. I still have to investigate the full consequences of that on the rest of the PostgreSQL code, but I guess it would at least imply making NOTIFYs preparable statements.
I was wondering what your opinion on this would be.

Best regards,
Arnaud Betremieux

----------------------------------------------------

Concernant la possibilité d'utiliser une table mémoire contenant les pks des lignes updatées a la place du listen/notify : PostgreSQL peut stocker une table en RAM si on donne une LOCATION sur un ramdisk lors du CREATE... pas genial.

Idée d'implementation en admettant que le NOTIFY marche comme on veut : un FlushEventListener qui regarde les notify et lance un StaleObjectStateException si une notif correspond a un objet du cache session. Faut-il que l'exception soit lancée aussi pour les objets non dirty ? Peut-être : ces objets ont pu servir de base aux modifications effectuées. L'application appelante peut toujours faire le tri dans les exceptions qui lui importent ou non puisqu'on indique l'objet dans l'exception. EN FAIT NON : hibernate ne le fait pas donc on conserve la logique, par contre on va le proposer en option, puisque ca peut a voir du sens.
Idéalement, la méthode appelée pour faire la verif serait statique et dans une classe statique (?) et prendrait une session hibernate en parametre, et c'est cette méthode qui serait appelée par onFlush. De cette facon on peut utiliser la methode aussi a la demande hors flush. Ajouter aussi une methode qui permet de verifier qu'un objet est stale. Les deux methodes ne generent pas d'exception (trop couteux), on se contente de retourner une liste d'objet stale :getStaleObjects(session), et un true/false pour le isStale(objetc). On retourne une exception dans le flushListener. Cyrille : il faudrait aussi un PersistListener pour lancer une exception si l'objet est stale au moment ou on le rend a la session pour persistence

Juste une idee probablement completement inutile mais pour memoire : on peut creer une vue regroupant toutes les tables et une notification pour la vue.

Il faudra penser a integrer les mappings restrictifs (WHERE ... ) pour ne pas tenir compte des objets non concernés dans les notifs ?

Avec Oracle, ca a l'air faisable : http://download.oracle.com/docs/cd/B28359_01/java.111/b31224/dbmgmnt.htm#CHDEJECF par contre il semble qu'il faille un thread dedié au listener. Par ailleurs Oracle ne retourne que des RowIDs... il va falloir trouver un moyen d'avoir une notif avec pk / version.

Probleme : on a pas moyen de savoir si au moment du load, un objet n'est pas deja stale... 

A voir : proxy -> on ne recupere de la base que suite a un appel de methode sur le proxy -> peut etre que l'evenement onload n'est pas celui qu'il faut regarder puisque dans ce cas au load on a pas encore fait le select

Est-ce que objet.refresh() fait un load ? Et pour les objets recuperes via des queries HQL ?

Que fait on lors d'un flush ? merge / update ?

Comment ne pas perdre les infos de modification sur les instances detachees ? et comment faire pour si la session rend sa connection jdbc ? Est-ce qu'on est pas limite a operer sur le cache L2 ?

On peut interdire a la session de rendre sa connection : ConnectionReleaseMode = ON_CLOSE

Fermeture d'une session : flush close, mais close ne flush pas, ce qui permet de se debarasser de la session si elle est foireuse.

Hibernate peut faire de la verification de stale sans versionning : avec optimistic-lock = all ! Ca ne marche que pour une session longue (qui suit l'objet)

Pas grave si on pert des notifs : on essaye juste de prevenir le plus tot possible. Dans tous les cas, le stalestate ariverra au commit au pire.

Avantages du systeme :
	- stale avant load
		- evition dirigee L2 par opposition au LRU
		- Eviter traitements metier inutiles
	- stale avant persist
		- L2
		- Eviter flush de tous les objets dirty de la transaction
	- stale avant dirtyCheck
		- L2
		- Eviter la verification de dirtyness, partant du principe qu'elle est plus couteuse que notre verification de version (?)
	- stale avant flush
		- L2
		- Eviter update voue a l'echec
	- stale avant commit
		- Evition L2 de version 
		- Si on a pas recu la notif, tant pis, l'update se fait et on revient au fonctionnement hibernate normal

On ne peut pas se contenter de travailler uniquement sur le L2 : il ne peut pas servir de reference : le fait qu'un objet ne soit pas dans le L2 ne veut pas dire qu'il est stale, il a pu etre evicté par un autre traitement

Pour oracle, c'est bon, on peut mettre ce qu'on veut dans les messages de notif : http://www.oracle.com/technology/products/ias/toplink/technical/tips/DbChangeNotification/index.htm

Comment gere t'on la notification d'un delete ? En versionné, a t'on un soft-delete ?

Comment distingue t'on un objet versionné ? comment recuperer sa version ? comment la comparer a une autre ? toujours incrementé ? utiliser timestamp ?  Est-ce l'un ou l'autre ?

Comment recuperer l'entityName d'un objet et son ID ?

Note: attention au triggers et au regles before update : on pourrait en avoir une autre qui changerait la requete. Donc il faut utiliser un after update. Du coup, on ne peut pas utiliser les RULES postgresql.
