select-before-update : seulement pour les objets transient ajoutes a la session via update.

Il semble qu'on puisse ajouter un where puisque check() verifie le number of rows affected et retourne une stale state exception
mais pas dans la logique d'hibernate : apparement si on est pas en mode versionne, pas de notion de stale

Cyrille : on va ajouter la notion de stale avec un update where toutes les colonnes pour les objets non versionnes, interet : bases qui ne peuvent pas etre passees en mode versions

=== listen/notify ===
CREATE RULE "listen_update" AS
	ON UPDATE TO objetpersistent
	DO ALSO NOTIFY 'UPDATE#'||objetpersistent||'#'||OLD.id; 

pas possible : syntaxe = notify <id_postgre>

si on peut convertir une string en identifiant, on pourrait utiliser un sha1 des infos interessantes. SHA1 en pgsql : 
encode(digest('ma chaine', 'sha1'), 'hex')

autres options : une rule par  en cache ou une rule pour tous les objets en cache updatee au fur et a mesure.
sauf que pas de ALTER RULE, donc DROP + CREATE a chaque fois

Mais un patch a ete propose qui permet de passer un parametre dans un NOTIFY : https://commitfest.postgresql.org/action/patch_view?id=210 on va donc pouvoir passer la table et l'id de l'objet qui a ete victime d'un update avec la prochaine version de postgresql !

On va faire une methode (voir ou la mettre) qui verifie une liste d'objets, et les passe a stale si necessaire. L'utilisateur pourra l'utiliser a la demande, et on l'utilisera aussi au debut du flush.

Dans un premier temps, on va faire un test en mettant tout le code dans flush

Apply du patch notify sur le dernier snapshot (2 decembre) : le patch passe, mais ca ne marche pas (syntax error quand on ajoute un payload dans un NOTIFY). Clonage du git (miroir du cvs) de postgresql, et recuperation de la version sur laquelle le patch semble s'appliquer : acfff4ac821da0f8088550fed65c4 (16 Nov). Make se plaint qu'il manque le parseur Bison, ce qui confirme qu'il devait y avoir un probleme de grammaire avec le snapshot (apparement bison sert a generer les .c a partir des .y pour la compilation, ce qui fait que le parseur que j'utilisais sur le snapshot etait celui du .c qui n'etait pas a jour)

Le patch semble ne supporter qu'un payload constant pour notify, ce qui n'apporte rien dans notre cas. En regardant la grammaire, il semblerait que le payload devrait etre un ctext_expr et pas un iconst, ce qui permettrait de mettre tout type de valeur comme payload, y compris un (select ...). Ca veut dire qu'il faudrait probablement transformer notify en preparable statement pour que le sql soit pris en compte.

Mail a Joachim Wieland (joe@mcknight.de), auteur du patch, 2 dec 2009
---------------------------------------------------

Sujet : your patch to PostgreSQL listen/notify

Hi,

I had a look at your patch, and played with it a bit. If I understand your code well, the payload for the notify has to be constant.
This bothers me since I was hoping the patch would allow me to pass a dynamic payload. My use case would be setting a notify rule on update on a table, and having the updated row pk, or some hashed form of it, as the notify payload, so listening applications could know which row was updated. The rule I had in mind would look like this in the simplest case:

CREATE RULE "listen_update" AS
	ON UPDATE TO my_table
	DO ALSO NOTIFY update_my_table OLD.id;

I'm not sure if there is any other way to do this apart from having a small table for storing updated ids, which would need to be queried regularly, which entails unnecessary database operations compared to a listen/notify implementation.
To allow for my use case, I was thinking about adding to your patch by changing the payload definition in the grammar to a ctext_expr or aexpr, so as to allow as a payload anything that coalesces to a suitable string. I still have to investigate the full consequences of that on the rest of the PostgreSQL code, but I guess it would at least imply making NOTIFYs preparable statements.
I was wondering what your opinion on this would be.

Best regards,
Arnaud Betremieux

----------------------------------------------------

Concernant la possibilité d'utiliser une table mémoire contenant les pks des lignes updatées a la place du listen/notify : PostgreSQL peut stocker une table en RAM si on donne une LOCATION sur un ramdisk lors du CREATE... pas genial.

Idée d'implementation en admettant que le NOTIFY marche comme on veut : un FlushEventListener qui regarde les notify et lance un StaleObjectStateException si une notif correspond a un objet du cache session. Faut-il que l'exception soit lancée aussi pour les objets non dirty ? Peut-être : ces objets ont pu servir de base aux modifications effectuées. L'application appelante peut toujours faire le tri dans les exceptions qui lui importent ou non puisqu'on indique l'objet dans l'exception. EN FAIT NON : hibernate ne le fait pas donc on conserve la logique, par contre on va le proposer en option, puisque ca peut a voir du sens.
Idéalement, la méthode appelée pour faire la verif serait statique et dans une classe statique (?) et prendrait une session hibernate en parametre, et c'est cette méthode qui serait appelée par onFlush. De cette facon on peut utiliser la methode aussi a la demande hors flush. Ajouter aussi une methode qui permet de verifier qu'un objet est stale. Les deux methodes ne generent pas d'exception (trop couteux), on se contente de retourner une liste d'objet stale :getStaleObjects(session), et un true/false pour le isStale(objetc). On retourne une exception dans le flushListener. Cyrille : il faudrait aussi un PersistListener pour lancer une exception si l'objet est stale au moment ou on le rend a la session pour persistence

Juste une idee probablement completement inutile mais pour memoire : on peut creer une vue regroupant toutes les tables et une notification pour la vue.

Il faudra penser a integrer les mappings restrictifs (WHERE ... ) pour ne pas tenir compte des objets non concernés dans les notifs ?

Avec Oracle, ca a l'air faisable : http://download.oracle.com/docs/cd/B28359_01/java.111/b31224/dbmgmnt.htm#CHDEJECF


