import java.util.HashMap;

public class NotifyFlushEventListener extends EventListener
	{
	// Events supported by hibernate :
	// AutoFlushEventListener 	Defines the contract for handling of session auto-flush events.
	// DeleteEventListener 	Defines the contract for handling of deletion events generated from a session.
	// DirtyCheckEventListener 	Defines the contract for handling of session dirty-check events.
	// EvictEventListener 	Defines the contract for handling of evict events generated from a session.
	// FlushEntityEventListener 	 
	// FlushEventListener 	Defines the contract for handling of session flush events.
	// Initializable 	An event listener that requires access to mappings to initialize state at initialization time.
	// InitializeCollectionEventListener 	Defines the contract for handling of collection initialization events generated by a session.
	// LoadEventListener 	Defines the contract for handling of load events generated from a session.
	// LockEventListener 	Defines the contract for handling of lock events generated from a session.
	// MergeEventListener 	Defines the contract for handling of merge events generated from a session.
	// PersistEventListener 	Defines the contract for handling of create events generated from a session.
	// PostDeleteEventListener 	Called after deleting an item from the datastore
	// PostInsertEventListener 	Called after insterting an item in the datastore
	// PostLoadEventListener 	Occurs after an an entity instance is fully loaded.
	// PostUpdateEventListener 	Called after updating the datastore
	// PreDeleteEventListener 	Called before deleting an item from the datastore
	// PreInsertEventListener 	Called before inserting an item in the datastore
	// PreLoadEventListener 	Called before injecting property values into a newly loaded entity instance.
	// PreUpdateEventListener 	Called before updating the datastore
	// RefreshEventListener 	Defines the contract for handling of refresh events generated from a session.
	// ReplicateEventListener 	Defines the contract for handling of replicate events generated from a session.
	// SaveOrUpdateEventListener 	Defines the contract for handling of update events generated from a session.

	private Map staleUids = new HashMap(); // Map de session -> Map de UID (string identifiant table + objet) -> true ?
					       // Selon comment se fait la comparaison des objets session, il pourra etre necessaire
					       // de faire un objet qui prend une session dans le constructeur et definit un nouvel equal
					       // qui verifie juste si on a affaire a la meme instance de session
	private Map versions = new HashMap(); // Map de UID -> derniere version connue
	private Stack notificationQueue;

	public Serializable ProcessLoadEvent(Event event, boolean throwStaleException) throws HibernateException
		{
		// il est peut etre deja stale. on regarde si dans versions on a cet objet et si c'est le cas on compare a notre version, sinon on considère comme clean (pas moyen de savoir). Si version correcte on retire de staleIds de cette session. Si version ancienne, on staleobjectstateexception, et on garde le staleId. Si pas de version connue, on garde la version comme plus recente connue.
		// Cas pas de versionnage : on retire l'objet des dirtyIds de cette session. On a pas de moyen de savoir si il est stale.
		}

	public Serializable onPostLoad(PostLoadEvent event) throws HibernateException
		{
		ProcessLoadEvent(event, true);
		return processEvent(event);
		}

	public Serializable onRefresh(RefreshEvent event) throws HibernateException
		{
		ProcessLoadEvent(event, true);
		processEvent(event);
		}

	public Serializable onPersist(PersistEvent event) throws HibernateException
		{
		return processEvent(event);
		}

	public Serializable onDirtyCheck(DirtyCheckEvent event) throws HibernateException
		{
		return processEvent(event);
		}

	public Serializable onFlush(FlushEvent event) throws HibernateException
		{
		return processEvent(event);
		}

	public Serializable onCommit(CommitEvent event) throws HibernateException
		{
		return processEvent(event);
		}

	public Serializable processEvent(Event event) throws HibernateException
		{
		Object object = event.getObject();
		Session session = event.getSession();
		updateStaleUidsAndVersions(session.getSessionFactory());
		if (isKnownToBeStaleInSession(object, session))
			{
			if (isKnownToBeStaleInL2(object))
				{
				session.getSessionFactory().evict(session.getEntityName(object), session.getIdentifier(object));
				}
			throw new StaleObjectStateException(object.class, id); // TODO: Should be optional for loads
			}
		return null;
		}

	public boolean isKnownToBeStaleInL2(Object object)
		{
		factory = ?;
	 	EntityPersister persister = factory.getEntityPersister(entityName);
		if (persister.isVersionned())
			{
			Field[] fields = object.getDeclaredFields();
			Versioning.getVersion(Object[] fields, persister) // Extract the optimistic locking value out of the entity state snapshot.
			// comparer version L2 et derniere version connue. Comment recuperer version L2 ?
			}
		else
			{
			// We can't know what version is in L2, so we can't know if it's stale
			return false;
			}
		}

	public boolean isKnownToBeStaleInSession(Object object, Session session)
		{
		String uid = uid(object);
		updateStaleUidsAndVersions(session.getSessionFactory());
		if ((staleIds.ContainsKey(session)) && (staleIds.get(session).ContainsKey(uid))) {return true;}
		if ((versions.ContainsKey(uid)) && (!version.get(uid).equald(object.get...)) {return true;}
		return false;
		}

	private string uid(Object object) // Unique Identifier pour l'objet, qui est aussi utilisé dans les notifications du SGBD. Pourrait etre simplement <nom table><separateur><pk> mais il peut etre necessaire pour faire face a des restrictions par exemple du NOTIFY d'utiliser un SHA1 ou autre.
		{
		}

	private void updateStaleUidsAndVersions(MagicSessionFactory sessionFactory)
		{
		// TODO: for implementations in which notifications update is synchronous, call it here
		while (!notificationQueue.empty())
			{
			Notofication notif = notificationQueue.pop();
			if (notif.getVersion()) {versions.put(notif.getUid(), Notif.getVersion());}
				{
				}
			List<Session> sessions = sessionFactory.getSessions())
			for (int i=0; i<sessions.length(); i++)
				{
				Session session = sessions[i];
				if (!staleUids.ContainsKey(session)) {staleUids.put(session, new HashMap());}
				staleUids.get(session).put(uid, notif.getUid());
				}
			}
		
		}
 
	private garbageCollector()
		{
		// TODO: remove the keys of closed sessions from the staleUids Map
		}
	}

public class Notification
	{
	private long Version;
	private String uid;

	public long getVersion()
		{
		return version;
		}

	public void setVersion(long v)
		{
		version = v;
		}

	public String getUid()
		{
		return uid;
		}

	public void setUid(String u)
		{
		uid = u;
		}
	}

public class MagicSessionFactory extends SessionFactory
	{
	private List<Session> sessions;

	public MagicSessionFactory(SessionFactory)
		{
		}

	public List<Session> getSessions()
		{
		return sessions;
		}

	public Session openSession()
		{
		Session session = super.openSession();
		sessions.Add(session);
		return session;
		}

	public Session openSession(Connection connection)
		{
		super.openSession(connection);
		}

	public Session openSession(Connection connection, boolean flushBeforeCompletionEnabled, boolean autoCloseSessionEnabled, ConnectionReleaseMode connectionReleaseMode)
		{
		super.openSession(connection, flushBeforeCompletionEnabled, autoCloseSessionEnabled, connectionReleaseMode);
		}

	public Session openSession(Connection connection, Interceptor sessionLocalInterceptor)
		{
		super.openSession(connection, sessionLocalInterceptor);
		}

	public Session openSession(Interceptor sessionLocalInterceptor)
		{
		super.openSession(sessionLocalInterceptor);
		}
	}

public class MagicAnnotationConfiguration extends AnnotationConfiguration
	{
	public MagicAnnotationConfiguration()
		{
		super();
		NotifyListener listener = new NotifyListener();
		this.getSessionEventListenerConfig().setLoadEventListener(listener);
		this.getSessionEventListenerConfig().setFlushEventListener(listener);
		}

	public MagicSessionFactory buildSessionFactory()
		{
		SessionFactory sf = super.buildSessionFactory();
		return (MagicSessionFactory) sf;
		}
	}

/************************************
 ***            Oracle            ***
 ************************************/
public class DCNDemoListener implements DatabaseChangeListener
	{
	private void onDatabaseChangeNotification(DatabaseChangeEvent e)
		{
		System.out.println(e.toString());
		}

	// Oracle
	private Map getLatestUpdates(Session session, OracleConnection conn)
		{
		Map updates = new HashMap()
		
		DatabaseChangeRegistration dcr = conn.registerDatabaseChangeNotification(prop);
		DCNDemoListener list = new DCNDemoListener();
		dcr.addListener(list);
		}
	}

/************************************
 ***            PostgreSQL        ***
 ************************************/
private Map getLatestUpdates(Session session, PGConnection conn)
	{
	org.postgresql.PGNotification notifications[] = pgconn.getNotifications();
	string[] latestUpdates;
	if (notifications != null)
		{
		for (int i=0; i<notifications.length; i++) {latestUpdates.add(notifications[i].getPayload());}
		}
	}
// Pour utiliser ce listener, dans la conf :
//<hibernate-configuration>
//    <session-factory>
//        ...
//        <event type="flush">
//            <listener class="ce listener"/>
//            <listener class="org.hibernate.event.def.DefaultFlushEventListener"/>
//        </event>
//    </session-factory>
//</hibernate-configuration>
